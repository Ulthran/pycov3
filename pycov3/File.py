import logging
from abc import ABC, abstractmethod
from itertools import groupby
from pathlib import Path

from .Sequence import Contig

class File(ABC):
    def __init__(self, fp: Path) -> None:
        super().__init__()
        self.fp = fp

        if not fp.exists():
            logging.error(f"{self.fp} does not exist")
            raise FileExistsError
        if fp.stat().st_size == 0:
            logging.error(f"{self.fp} is empty")
            raise ValueError
        if not fp.is_readable():
            logging.error(f"{self.fp} is not readable")
    
    @abstractmethod
    def parse(self) -> None:
        pass

    @abstractmethod
    def write(self) -> None:
        pass


class FastaFile(File):
    def __init__(self, fp: Path, coverage_params: dict) -> None:
        super().__init__(fp)
        self.contigs = []

    def parse(self) -> list:
        with open(self.fp) as f:
            faiter = (x[1] for x in groupby(f, lambda line: line[0] == ">"))

            for header in faiter:
                # drop the ">"
                header_str = header.__next__()[1:].strip()

                # join all sequence lines to one.
                seq_str = "".join(s.strip() for s in faiter.__next__())

                yield (header_str, seq_str)

    def write(self):
        pass

    def get_contigs(self):
        self.contigs = [Contig()]

"""
This is designed to work with SAM files generated by bowtie2, 
other tools aren't guaranteed to have the same formatting
"""
class SamFile(File):
    def __init__(self, fp: Path) -> None:
        super().__init__(fp)

    def parse(self) -> list:
        with open(self.fp, 'r') as sam_file:
            for line in sam_file:
                if line.startswith('@'):
                    continue  # Skip header lines
                fields = line.split('\t')
                read_name = fields[0]
                flag = int(fields[1])
                reference_name = fields[2]
                position = int(fields[3])
                mapping_quality = int(fields[4])
                cigar = fields[5]
                # Additional fields can be parsed based on your needs
                
                parsed_read = {
                    'read_name': read_name,
                    'flag': flag,
                    'reference_name': reference_name,
                    'position': position,
                    'mapping_quality': mapping_quality,
                    'cigar': cigar
                    # Add more fields as needed
                }
                yield parsed_read

    def write(self):
        pass