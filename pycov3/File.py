import logging
import math
from abc import ABC, abstractmethod
from itertools import groupby
from pathlib import Path

from .Sequence import Contig


class File(ABC):
    def __init__(self, fp: Path) -> None:
        super().__init__()
        self.fp = fp
    
    def exists(self) -> bool:
        if not self.fp.exists():
            logging.error(f"{self.fp} does not exist")
            return False
        if self.fp.stat().st_size == 0:
            logging.error(f"{self.fp} is empty")
            return False
        return True

    @abstractmethod
    def parse(self) -> None:
        pass

    @abstractmethod
    def write(self) -> None:
        pass


class FastaFile(File):
    def __init__(self, fp: Path, window_params: dict) -> None:
        super().__init__(fp)
        self.window_params = window_params
        self.contigs = {}

        try:
            stem = fp.stem.split(".")
            self.sample = stem[0]
            self.bin = stem[1]
        except IndexError:
            logging.error(f"FASTA filename {self.fp} not of format {{sample}}.{{bin}}.fasta/.fa/.fna")
            raise ValueError

    def parse(self) -> list:
        with open(self.fp) as f:
            faiter = (x[1] for x in groupby(f, lambda line: line[0] == ">"))

            for header in faiter:
                # drop the ">"
                header_str = header.__next__()[1:].strip()

                # join all sequence lines to one.
                seq_str = "".join(s.strip() for s in faiter.__next__())

                yield (header_str, seq_str)

    def write(self):
        pass

    def generate_contigs(self):
        self.contigs = {n: Contig(n, s, **self.window_params) for n, s in self.parse()}


"""
This is designed to work with SAM files generated by bowtie2, 
other tools aren't guaranteed to have the same formatting of latter columns
"""
class SamFile(File):
    def __init__(self, fp: Path) -> None:
        super().__init__(fp)
        try:
            stem = fp.stem.split("_")
            self.sample = stem[0]
            self.bin = stem[1]
        except IndexError:
            logging.error(f"SAM filename {self.fp} not of format {{sample}}_{{bin}}.sam")
            raise ValueError

    def parse(self) -> list:
        with open(self.fp, "r") as sam_file:
            for line in sam_file:
                if line.startswith("@"):
                    continue  # Skip header lines
                fields = line.split("\t")
                read_name = fields[0]
                flag = int(fields[1])
                reference_name = fields[2]
                position = int(fields[3])
                mapping_quality = int(fields[4])
                cigar = fields[5]
                # Find XM field for mismatches
                mismatch = 0
                for i in [13, 14, 15, 12, 11]:
                    if fields[i].split(":") == "XM":
                        mismatch = int(fields[i].split(":")[2])
                        break

                parsed_read = {
                    "read_name": read_name,
                    "flag": flag,
                    "reference_name": reference_name,
                    "position": position,
                    "mapping_quality": mapping_quality,
                    "cigar": cigar,
                    "mismatch": mismatch
                }
                yield parsed_read

    def write(self):
        pass


class Cov3File(File):
    def __init__(self, fp: Path, bin: str, mapq_cutoff: int = 5, mapl_cutoff: int = 50, max_mismatch_ratio: float = 0.03) -> None:
        super().__init__(fp)
        self.bin = bin

        self.mapq_cutoff = mapq_cutoff
        self.mapl_cutoff = mapl_cutoff
        self.max_mismatch_ratio = max_mismatch_ratio

        if not (0 <= self.mapq_cutoff <= 30):
            logging.error(f"MapQ cutoff of {self.mapq_cutoff} is not between 0 and 30")
            raise ValueError
        if not (30 <= self.mapl_cutoff <= 80):
            logging.error(f"MapL cutoff of {self.mapl_cutoff} is not between 30 and 80")
            raise ValueError
        if not (0.01 <= self.max_mismatch_ratio <= 0.3):
            logging.error(f"Max mismatch ratio of {self.max_mismatch_ratio} is not between 0.01 and 0.30")
            raise ValueError
        
        self.min_cov_window = 0
        self.min_window_count = 5
    
    def parse(self) -> None:
        pass

    def write(self, sams: list, fasta: FastaFile) -> None:
        if not fasta.contigs:
            fasta.generate_contigs()
        
        with open(self.fp, "w") as f_out:
            for sam in sams:
                sam_name = sam.fp.stem
                current_contig = ""
                coverages = {}
                for line in sam.parse():
                    contig_name = line['reference_name']
                    contig = fasta.contigs[contig_name]
                    contig_len = contig.seq_len
                    edge_length = contig.edge_length
                    window_size = contig.window_size
                    window_step = contig.window_step

                    if contig.windows: # Check that the contig is big enough to be windowed
                        if current_contig != contig_name and current_contig: # Only output to file on contig change while parsing SAM
                            first_i = contig.windows[0].start
                            last_i = contig.windows[-1].end
                            first_step = int((first_i - 1 - edge_length) / window_step)
                            last_step = int((last_i - 1 - edge_length) / window_step)

                            cov_step = []
                            cov_window_sum = 0
                            qualified_info = [] # Information to output
                            n = 0 # Window index

                            for step in range(first_step, last_step):
                                if step in coverages.keys():
                                    cov_step.push(coverages[step])
                                    cov_window_sum += coverages[step]
                                else:
                                    cov_step.push(0)

                                if len(cov_step) == window_size / window_step:
                                    avg_cov_window = cov_window_sum / window_size
                                    log_cov = math.log(avg_cov_window) / math.log(2)
                                    window = contig.windows[n]
                                    gc_content = window.gc_content
                                    n += 1
                                    cov_window_sum -= cov_step.pop(0)
                                    if avg_cov_window > self.min_cov_window:
                                        qualified_info.append(f"{log_cov},{gc_content},{sam_name},{contig_name},{contig_len}")

                            if n >= self.min_window_count and len(qualified_info) == n:
                                for info in qualified_info:
                                    f_out.write(info)

                            coverages = {}
                        
                        current_contig = contig_name
                        mapl = self.calculate_mapl(line["cigar"])
                        if line["mapping_quality"] >= self.mapq_cutoff and mapl >= self.mapl_cutoff and line["mismatch"] <= self.max_mismatch_ratio * mapl:
                            start_step = int((line["position"] - 1 - edge_length) / window_step)
                            end_step = int((line["position"] - 1 + mapl - edge_length) / window_step)

                            coverages[start_step] += window_step - ((line["position"] - 1 - edge_length) % window_step)
                            coverages[end_step] += (line["position"] - 1 + mapl - edge_length) % window_step
                            for step in range(start_step + 1, end_step):
                                coverages[step] += window_step
    
    @staticmethod
    def calculate_mapl(cigar: str) -> int:
        operations = []
        current_length = ''
        
        for char in cigar:
            if char.isdigit():
                current_length += char
            else:
                operations.append((int(current_length), char))
                current_length = ''
        
        return sum([n for n, c in operations if c == 'M' or c == 'D']) - sum([n for n, c in operations if c == 'I'])